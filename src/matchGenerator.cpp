#include "matchGenerator.hpp"
#include <string>

/*

PREFERENCES
        0   1      2      3
--------|ID |minAge|maxAge|gender|
user0   |   |      |      |      |
user1   |   |      |      |      |
user2   |   |      |      |      |

        0   1   2   3   4
DATA
--------|ID |ft1|ft2|ft3|ft4|
user0   |   |   |   |   |   |
user1   |   |   |   |   |   |
user2   |   |   |   |   |   |

*/


/**
 * @brief Pair<int, double> comparation to sort a vector<pair<int, double>> based on the second value
 * 
 * @param a first pair
 * @param b second pair
 * 
 * @return true or false
 */
bool comparePair(std::pair<int, double> a, std::pair<int, double> b){
    return a.second < b.second;
}


/**
 * @brief Construct a new Match Generator:: Match Generator object
 * 
 * @param id id of user is going to make the match
 */
MatchGenerator::MatchGenerator(int id){
    _id = id;
}


/**
 * @brief Calculates the 3 closest users to the current user
 * 
 * @param matchFullDistances matrix generated in MatchGenerator::matchAll
 * 
 * @return vector<int> id of the users
 */
std::vector<int> MatchGenerator::match(){
    std::vector<std::pair<int, double>> matchFull = matchAll();

    if(matchFull.size() == 0) throw matchException();

    std::vector<int> match3;

    if(matchFull.size() >= 3){
        if(matchFull[0].first != _id){
            match3.push_back(matchFull[0].first);
            match3.push_back(matchFull[1].first);
            match3.push_back(matchFull[2].first);
        }
        else{
            match3.push_back(matchFull[1].first);
            match3.push_back(matchFull[2].first);
            match3.push_back(matchFull[3].first);
            
        }

    }
    else{
        for(int i = 0; i<matchFull.size(); i++){
            if(matchFull[i].first != _id) match3.push_back(matchFull[i].first);
        }
    }
    
    return match3; 
}


/**
 * @brief Calculates the full match matrix based on L2 norm
 * 
 * @return vector<pair<int, double>> pair containing id and the distance from the user
 */
std::vector<std::pair<int, double>> MatchGenerator::matchAll(){

    vvd dataFiltered = getCharacteristicsMatrixFiltered();


    if(dataFiltered.size() == 0) throw matchException();

    // If there is only less than 3 compatible users
    if(dataFiltered.size() < 4){
        std::vector<std::pair<int, double>> a;
        std::pair<int,double> b (dataFiltered[0][0], -1);
        for(int i = 1; i<dataFiltered.size(); i++){
            b.first = dataFiltered[i][0];
            b.second = -1;
            a.push_back(b);
        }
        return a;
    }

    // Make the current user go to the top
    sortData(dataFiltered);

    // make the id vector excluding the the current user, which is the first int the vector
    std::vector<int> ids;
    for(int i = 1; i < dataFiltered.size(); i++){
        ids.push_back(dataFiltered[i][0]);
    }
    
    // remove id e keep matrix
    vvd dataNoId;
    for(int i = 0; i<dataFiltered.size(); i++){
        std::vector<double> temp;
        for(int j = 1; j<dataFiltered[0].size();j++){
            temp.push_back(dataFiltered[i][j]);
        }
        dataNoId.push_back(temp);
        temp.clear();
    }

    // Pca calculation
    MatrixXd matrixNoId = vectorToMatrix(dataNoId);
    Pca pca;
    MatrixXd pcaMatrix = pca.pca(matrixNoId);
    std::vector<std::vector<double>> v = matrixToVector(pcaMatrix);

    // Verify if the Pca algorithm has succeded
    for(auto i : v){
        for(auto j : i){
            if(isnan(j)){
                throw matchException();
            }
        }
    }

    std::vector<double> distances = calculatesDistance(v);

    std::vector<std::pair<int, double>> idDistances;
    
    for(int i = 0; i<distances.size(); i++){
        idDistances.push_back(std::pair<int,double> (ids[i], distances[i]));
    }

    sort(idDistances.begin(), idDistances.end(), comparePair);

    return idDistances;
}


/**
 * @brief Algorithm to calculate the L2 norm btwn the current user and the other users
 * 
 * @param pcaData matrix generated by PCA algorithm
 * @param dimensions how many dimensions you want from pca
 * 
 * @return vector<double> array containing all the distances 
 */
std::vector<double> MatchGenerator::calculatesDistance(vvd& pcaData, int dimensions){
    std::vector<double> distances;

    for(int j = 1; j<pcaData[0].size(); j++){
        double sum = 0;
        for(int i = 0; i<dimensions; i++){
            sum += pow(pcaData[i][j] - pcaData[i][0], 2);
        }
        distances.push_back(sum);
    }

    return distances;
}


/**
 * @brief Function to make the filtering easier. Makes the row of the current user go to the top of the matrix.
 * 
 * @param data data with id
 */
void MatchGenerator::sortData(vvd& data){
    bool success = false;
    std::vector<double> aux;
    for(int i = 0; i<data.size(); i++){
        if(_id == data[i][0]){
            success = true;
            aux = data[0];
            data[0] = data[i];
            data[i] = aux;
            break;
        }
    }

    if(!success) throw matchException();
}


/**
 * @brief  Return the matrix with the characteristics of compatible users
 * 
 * @return vvd filteredDataMatrix
 */
vvd MatchGenerator::getCharacteristicsMatrixFiltered(){
    Database database("database.db");

    std::vector<int> compatible = database.getMatchCompatibleIds(_id);
    vvd data = database.getCharacteristicsDatabase(compatible);
    
    return data;
}


/**
 * @brief Convert MatrixXd to vector<vector<double>> 
 * 
 * @param eMatrix MatrixXd
 * 
 * @return vector<vector<double> converted
*/
vvd MatchGenerator::matrixToVector(MatrixXd& eMatrix){

    int rows = eMatrix.rows();
    int cols = eMatrix.cols();

    vvd mat(rows, std::vector<double> (cols));

    for(int i = 0; i<rows; i++){
        for(int j = 0; j<cols; j++){
            mat[i][j] = eMatrix(i, j);
        }
    }

    return mat;
}


/**
 * @brief Convert vector to MatrixXd
 * 
 * @param vMatrix 2D vector<numeric>
 * 
 * @return MatrixXd converted
*/
MatrixXd MatchGenerator::vectorToMatrix(vvd& vMatrix){

    int rows = vMatrix.size();
    int cols = vMatrix[0].size();

    MatrixXd mat(rows, cols);

    for(int i = 0; i<rows; i++){
        for(int j = 0; j<cols; j++){
            mat(i, j) = vMatrix[i][j];
        }
    }

    return mat;
}


